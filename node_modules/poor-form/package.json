{
  "name": "poor-form",
  "version": "1.1.3",
  "description": "Built upon formaline's ultrafast parser, truly a formidable competitor.",
  "main": "lib/poor-form.js",
  "directories": {
    "lib": "lib"
  },
  "dependencies": {
    "qap": "2.1.x",
    "bufferjs": "2.x"
  },
  "devDependencies": {},
  "scripts": {
    "test": "node example-md5sum-service.js & sleep 1; bash test.sh"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/coolaj86/poor-form.git"
  },
  "keywords": [
    "formaline",
    "formidable",
    "multipart",
    "upload",
    "form",
    "connect",
    "express",
    "post",
    "parser"
  ],
  "author": {
    "name": "AJ ONeal"
  },
  "license": "MIT",
  "readme": "## PoorForm\n\nPoorForm uses [formaline](https://github.com/rootslab/formaline)'s\nultra-fast parser ([QAP](https://github.com/rootslab/qap)) to create a much simpler multi-part form parser.\n\nIt may be *insignificantly faster* than both formidable and formaline, but that's not the point.\n\n**The point is** that it's a **simple base to build upon**, kitchen sink *not* included.\n\nTruly a [formidable](https://github.com/felixge/node-formidable) competitor.\n\n    npm install poor-form\n\n## Test\n\nThere are two tests.\n\nThe first walks a directory and checks the md5 sums of the files against the md5sums calculated by the server.\n\nThe second creates a few thousand form submissions where each form has one more byte than the previous form\n(an attempt to catch off-by-one errors).\n\n    git clone git://github.com/coolaj86/poor-form.git\n    cd poor-form\n    cp npm-shrinkwrap.bak.json npm-shrinkwrap.json\n    npm install --dev\n    node test/example-md5sum-service.js 4444 &\n    node test/md5sum-test.js .\n    node test/md5sum-bits-test.js\n\nIf you encounter any errors running the test, it's probably just an issue of dependencies\n(there's some `instanceof` magic that fails if any modules from `file-api` are installed twice),\nbut the `npmshrinkwrap.json` should be preventing this.\n\n## API\n\n  * [`PoorForm.create(req)`](#poorformcreaterequest)\n  * [`PoorForm#on('fieldstart', fn)`](#poorformonfieldstart-function-headers---)\n  * [`PoorForm#on('fielddata', fn)`](#poorformonfielddata-function-buffer---)\n  * [`PoorForm#on('fieldend', fn)`](#poorformonfieldend-function----)\n  * [`PoorForm#on('formend', fn)`](#poorformonformend-function----)\n  * [`PoorForm#total`](#poorformloaded)\n  * [`PoorForm#loaded`](#poorformtotal)\n\n### PoorForm.create(request)\n\nReturns a `PoorForm` emitter instance if `!req.complete` and `/multipart/.test(req.headers['content-type'])`.\n\nReturns `null` otherwise - either it's not a multi-part form, or the form has already been parsed.\n\n#### Example\n\n```javascript\n// Using Connect, for example\napp.use(function (req, res, next) {\n  var poorForm = PoorForm.create(req)\n    , fields = []\n    , count = 0\n    , curField\n    ;\n\n  if (!poorForm) {\n    console.log(\"Either this was already parsed or it isn't a multi-part form\");\n    next();\n    return;\n  }\n\n  // poorForm.on('fieldstart', ...)\n  // ...\n});\n```\n\n### PoorForm#on('fieldstart', function (headers) { ... })\n\nEmitted each time a new field is encountered.\n\n`headers` will contain all raw mime headers (with lower-cased keys) as well as a few shortcut keys\n\n```javascript\nheaders = {\n    name: \"foo-fieldname\"             // parsed value from Content-Disposition\n  , filename: \"big.bin\"               // parsed value from Content-Disposition\n  , type: \"application/json\"          // Just the MIME-type of the Content-Type\n  , 'content-type': \"application/json; charset=utf-8\"\n  , 'content-disposition': 'form-data; name=\"foo-fieldname\"; filename=\"big.bin\"'\n  , ...                               // any other raw headers (usually none)\n}\n```\n\n#### Example\n\n```javascript\npoorForm.on('fieldstart', function (headers) {\n  var tmpPath = '/tmp/upload-' + count + '.bin'\n    ;\n\n  count += 1;\n  curField = {};\n\n  if (headers.filename) {\n    console.log('Probably a file and probably has a mime-type', headers.type);\n    curField.fw = fs.createWriteStream(tmpPath);\n    curField.tmpPath = tmpPath;\n  } else {\n    console.log('Probably a field without a mime-type', headers.type);\n    curField.value = '';\n  }\n\n  curField.totalBytes = 0;\n  curField.headers = headers;\n});\n```\n\n### PoorForm#on('fielddata', function (buffer) { ... })\n\nEmitted for each chunk of data that belongs to a field or file (no headers, whitespace, etc).\n\n```javascript\npoorForm.on('fielddata', function (buffer) {\n  if (curField.fw) {\n    curField.fw.write(buffer);\n    console.log('Just wrote', buffer.length, 'bytes of a file');\n  } else {\n    curField.value += buffer.toString('utf8');\n  }\n\n  curField.totalBytes += buffer.length;\n});\n```\n\nNOTE: It's very possible for a single field with very few bytes to come in with multiple chunks\n\n### PoorForm#on('fieldend', function () { ... })\n\nEmitted when the current field or file has completed.\n\n```javascript\npoorForm.on('fieldend', function () {\n  var lastField = curField\n    ;\n\n  if (curField.fw) {\n    curField.fw.end();\n    curField.fw = undefined;\n    console.log('Just wrote a file of ', curField.totalBytes, 'bytes');\n    fs.rename(curField.tmpPath, '/tmp/' + curField.headers.filename, function () {\n      console.log('Renamed', lastField.tmpPath, 'to', lastField.headers.filename);\n    });\n  } else {\n    console.log('Just received', curField.headers.name + ':' + curField.value);\n  }\n\n  fields.push(curField);\n  curField = null;\n});\n\n```\n\n### PoorForm#on('formend', function () { ... })\n\nEmitted when the end-of-form boundary has been encountered.\n\n```javascript\npoorForm.on('formend', function () {\n  res.end(JSON.stringify(fields, null, '  '));\n});\n```\n\n### PoorForm#loaded\n\nNumber of bytes received so far - including all headers, whitespace, form fields, and files.\n\n```javascript\nreq.on('data', function () {\n  var ratio = poorForm.loaded / poorForm.total\n    , percent = Math.round(ratio * 100)\n    ;\n\n  console.log(percent + '% complete (' + poorForm.loaded + ' bytes)');\n  // might be 0, if poorForm.total is Infinity\n});\n```\n\n### PoorForm#total\n\nThe total number of bytes in the form - the same as `req.headers['content-length']`.\n\n```javascript\nconsole.log(poorForm.total + 'bytes received thus far');\n```\n\n**NOTE**: If the content encoding is `chunked` poorForm.total will be `Infinity`.\n\nExample: An md5sum webservice\n===\n\n```javascript\n/*jshint strict:true node:true es5:true onevar:true laxcomma:true laxbreak:true eqeqeq:true immed:true latedef:true unused:true undef:true*/\n(function () {\n  \"use strict\";\n\n  var connect = require('connect')\n    , PoorForm = require('poor-form')\n    , crypto = require('crypto')\n    , port = process.argv[2] || 3000\n    , server\n    , app\n    ;\n\n  // An md5sum service\n  app = connect.createServer()\n    .use(function (req, res, next) {\n        var poorForm = PoorForm.create(req)\n          , hash\n          , info\n          , hashes = []\n          ;\n\n        if (!poorForm) {\n          console.log(\"Either this was already parsed or it isn't a multi-part form\");\n          next();\n          return;\n        }\n\n        poorForm.on('fieldstart', function (headers) {\n          console.log('[fieldstart]', headers.filename || headers.name);\n          hash = crypto.createHash('md5');\n          info = headers;\n        });\n\n        poorForm.on('fielddata', function (chunk) {\n          hash.update(chunk);\n        });\n\n        poorForm.on('fieldend', function () {\n          info.md5sum = hash.digest('hex');\n          console.log(info.md5sum);\n          hashes.push(info);\n        });\n\n        poorForm.on('formend', function () {\n          console.log('[formend]');\n          res.end(JSON.stringify({ \"success\": true, \"result\": hashes }));\n        });\n      })\n    ;\n\n  server = app.listen(port, function () {\n    console.log(server.address());\n  });\n\n}());\n```\n\n## Possible Future Enhancements\n\nThere are a few derivations of the `multipart/*` type:\n\n  * `multipart/form-data` (with dispositions `form-data` and `file`) [W3 Spec](http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4)\n  * `multipart/mixed` (similar to the `file` disposition, but without a declared disposition or `filename`) [W3 RFC 1341](http://www.w3.org/Protocols/rfc1341/7_2_Multipart.html)\n  * `multipart/alternative`\n  * `multipart/digest`\n  * `multipart/parallel`\n\n`poor-form` could *very* easily be adapted to handle these types as well.\nHowever, I don't know of any practical use for them at the moment.\n\n## Bugs\n\nIf a form ends unexpectedly, `curFile` should be closed.\n\nNeeds an error for when a form writes past the end boundary\n\nNeeds a default size limit on headers (4k would be more than reasonable) before sending an error\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/coolaj86/poor-form/issues"
  },
  "_id": "poor-form@1.1.3",
  "dist": {
    "shasum": "eb2451a5fb21adeff7a39eb4697e94c23e619a6c"
  },
  "_from": "poor-form@1.1.x",
  "_resolved": "https://registry.npmjs.org/poor-form/-/poor-form-1.1.3.tgz"
}
